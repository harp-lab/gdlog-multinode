
.type input_reg <: symbol
.type reg_nullable <: symbol
.type register <: reg_nullable
.type address <: unsigned
.type operand_code <: unsigned
.type operand_index <: unsigned

.type limit_type <: symbol
.type block_type <: symbol

.type access_mode <: symbol
.type symbol_position <: symbol

.type stack_var = [BaseReg:register,StackPos:number]
.type condition_code <: symbol

.decl block_last_instruction(Block:address,EA:address)
.input block_last_instruction

.decl jump_table_target(EA:address,Dest:address)
// .input jump_table_target
.output jump_table_target
.printsize jump_table_target

.decl block_next(Block:address,BlockEnd:address,NextBlock:address)
.output block_next
.printsize block_next

.decl compare_and_jump_immediate(EA_cmp:address,EA_jmp:address,CC:condition_code,Reg:register,Immediate:number)
// .input compare_and_jump_immediate
.printsize compare_and_jump_immediate
.output compare_and_jump_immediate

.decl direct_jump(src:address, dest:address)
.input direct_jump

.decl cmp_defines(EA_jmp:address,EA_dst:address,Reg:register)
.printsize cmp_defines

.decl may_fallthrough(o:address,d:address)
.input may_fallthrough

.decl flags_and_jump_pair(EA_flags:address,EA_jmp:address,CC:condition_code)
// .input flags_and_jump_pair
.printsize flags_and_jump_pair
.output flags_and_jump_pair

.decl arch_cmp_operation(Operation:symbol)
.input arch_cmp_operation

.decl cmp_immediate_to_reg(EA:address,Reg:register,Imm_index:operand_index,Immediate:number)
.input cmp_immediate_to_reg

.decl instruction(ea:address,size:unsigned,prefix:symbol,opcode:symbol,
          op1:operand_code,op2:operand_code,op3:operand_code,op4:operand_code,
          immOffset:unsigned,displacementOffset:unsigned)
.input instruction

.decl instruction_get_op(ea:address, index:operand_index, operator:operand_code)
.input instruction_get_op

.decl op_indirect(Code:operand_code,Reg1:input_reg,Reg2:input_reg,Reg3:input_reg,
        Multiplier:number,Offset:number,SizeBytes:unsigned)
.input op_indirect

.decl op_immediate(Code:operand_code,Offset:number,SizeBytes:unsigned)
.input op_immediate

.decl compare_and_jump_indirect(EA_cmp:address,EA_jmp:address,CC:condition_code,IndirectOp:operand_code,Immediate:number)
.output compare_and_jump_indirect
.printsize compare_and_jump_indirect

.decl cmp_reg_to_reg(EA:address,Reg1:register,Reg2:register)
.input cmp_reg_to_reg

.decl compare_and_jump_register(EA_cmp:address,EA_jmp:address,CC:condition_code,Reg1:register,Reg2:register)
.output compare_and_jump_register
.printsize compare_and_jump_register

.decl value_reg(EA:address,Reg:register,
                EA_reg1:address,Reg1:reg_nullable,Multiplier:number,Offset:number,Steps:unsigned)
.input value_reg
.output value_reg
.printsize value_reg

.decl reg_def_use_def_used(EA_def:address,Var:register,EA_used:address,Index_used:operand_index)
.input reg_def_use_def_used
.decl reg_def_use_def_used_debug(EA_def:address,Var:register,EA_used:address,Index_used:operand_index)
.output reg_def_use_def_used_debug
.printsize reg_def_use_def_used_debug

.decl const_value_reg_used(UsedEA:address,EADef:address,EARegDef:address,Reg:register,Value:number)
.output const_value_reg_used
.printsize const_value_reg_used

.decl reg_used_for(EA:address,Reg:register,Type:symbol)
.input reg_used_for

.decl def_used_for_address(EA_def:address,Reg:register,Type:symbol)
.output def_used_for_address
.printsize def_used_for_address

.decl arch_memory_access(AccessType:symbol,EA:address,SrcOp:operand_index,DstOp:operand_index,
    DirectReg:register,BaseReg:reg_nullable,IndexReg:reg_nullable,Mult:number,Offset:number)
.input arch_memory_access

.decl stack_def_use_def_used(EA_def:address,VarDef:stack_var,EA_used:address,VarUsed:stack_var,Index_used:operand_index)
.decl stack_def_use_def_used_(EA_def:address,VarDef1:register, VarDef2:number ,EA_used:address,VarUsed1: register, VarUsed2: number,Index_used:operand_index)
.input stack_def_use_def_used
.output stack_def_use_def_used_

.decl arch_condition_flags_reg(Reg:register)
.input arch_condition_flags_reg

.decl arch_jump(EA:address)
.input arch_jump

.decl arch_conditional(EA:address,CC:condition_code)
.input arch_conditional

.decl jump_table_element_access(EA:address,Size:unsigned,TableStart:address,RegIndex:register)
.output jump_table_element_access
.printsize jump_table_element_access

.decl pc_relative_operand(src:address,index:operand_index, dest:address)
.input pc_relative_operand

.decl data_access(EA:address,Op_index:operand_index,RegSegment:reg_nullable,RegBase:reg_nullable,RegIndex:reg_nullable,Mult:number,Offset:number,Size:unsigned)
.input data_access

.decl take_address(Src:address,Address_taken:address)
.input take_address

.decl arch_reg_reg_arithmetic_operation(EA:address,Dst:register,Src1:register,Src2:register,Mult:number,Offset:number)
.input arch_reg_reg_arithmetic_operation

.decl data_segment(Begin:address,End:address)
.input data_segment

.decl arch_extend_load(EA:address,Signed:unsigned,SrcBits:unsigned)
.input arch_extend_load

.decl jump_table_signed(TableStart:address,Signed:unsigned)
.output jump_table_signed
.printsize jump_table_signed

.decl arch_extend_reg(EA:address,Reg:register,Signed:unsigned,SrcBits:unsigned)
.input arch_extend_reg

.decl instruction_get_dest_op(EA:address,Index:operand_index,Op:operand_code)
.input instruction_get_dest_op

.decl op_regdirect(Code:operand_code,RegisterName:input_reg)
.input op_regdirect

.decl reg_map(RegIn:input_reg,Reg:register)
.input reg_map

.decl instruction_get_src_op(EA:address,Index:operand_index,Op:operand_code)
.input instruction_get_src_op

.decl arch_register_size_bytes(Reg:input_reg,Size:unsigned)
.input arch_register_size_bytes

.decl jump_table_start(EA_jump:address,Size:unsigned,TableStart:address,TableRef:address,Scale:number)
.output jump_table_start
.printsize jump_table_start

.decl reg_call(Src:address,Reg:register)
.input reg_call

.decl code_in_block(EA:address,Block:address)
.input code_in_block

.decl reg_jump(Src:address,Reg:register)
.input reg_jump

.decl relative_jump_table_entry_candidate(EA:address,TableStart:address,Size:unsigned,Reference:address,Dest:address,Scale:number,Offset:number)
.input relative_jump_table_entry_candidate

.decl last_value_reg_limit(From:address,To:address,Reg:register,Value:number,LimitType:limit_type,Steps:unsigned)
.output last_value_reg_limit
.printsize last_value_reg_limit

.decl value_reg_limit(From:address,To:address,Reg:register,Value:number,LimitType:limit_type)
.output value_reg_limit
// .input value_reg_limit

.decl reg_def_use_defined_in_block(Block:address,Var:register)
.input reg_def_use_defined_in_block

.decl conditional_jump(src:address)
.input conditional_jump

.decl no_value_reg_limit(EA_jmp:address)
.input no_value_reg_limit

.decl limit_reg_op(EA:address,DstReg:register,SrcReg:register,Offset:number)
.input limit_reg_op

.decl reg_def_use_block_last_def(EA:address,EA_def:address,Var:register)
.input reg_def_use_block_last_def

.decl arch_move_reg_imm(EA:address,Dst:register,Imm:number,ImmIndex:operand_index)
.input arch_move_reg_imm

.decl reg_def_use_used(EA:address,Var:register,Index:operand_index)
.input reg_def_use_used

.decl value_reg_unsupported(EA:address, Reg:register)
.output value_reg_unsupported
.printsize value_reg_unsupported

.decl arch_move_reg_reg(EA:address,Dst:register,Src:register)
.input arch_move_reg_reg

.decl track_register(Reg:register)
.input track_register

.decl arch_call(EA:address,DestOperandIndex:operand_index)
.input arch_call

.decl reg_def_use_live_var_at_block_end(Block:address,BlockUsed:address,Var:register)
.input reg_def_use_live_var_at_block_end

.decl reg_def_use_live_var_def(Block:address,VarIdentity:register,LiveVar:register,EA_def:address)
.input reg_def_use_live_var_def

.decl reg_def_use_live_var_used(Block:address,LiveVar:register,UsedVar:register,EA_used:address,Index:operand_index,Moves:unsigned) overridable
.decl reg_def_use_live_var_used_tmp1(Block:address,LiveVar:register,EA_used:address,Index:operand_index) overridable
.input reg_def_use_live_var_used

.decl reg_def_use_live_var_at_prior_used(EA_used:address,BlockUsed:address,Var:register)
.input reg_def_use_live_var_at_prior_used

.decl reg_def_use_return_block_end(Callee:address,CalleeEnd:address,Block:address,BlockEnd:address)
.input reg_def_use_return_block_end

.decl reg_def_use_return_val_used(EA_call:address,Callee:address,Reg:register,EA_used:address,Index_used:operand_index)
.output reg_def_use_return_val_used
.printsize reg_def_use_return_val_used

.decl arch_return_reg(Reg:register)
.input arch_return_reg

.decl direct_call(EA:address,Dest:address)
.input direct_call

.decl reg_has_base_image(EA:address,Reg:register)
.input reg_has_base_image

.decl limit_type_map(CC:condition_code,BranchLT:limit_type,FallthroughLT:limit_type,BranchOffset:number,FallthroughOffset:number)
.input limit_type_map

.decl next(n:address,m:address)
.input next

block_next(Block,EA,Dest) :- 
   block_last_instruction(Block,EA),
   jump_table_target(EA,Dest).

cmp_defines(EA_jmp,EA_dst,Reg) :- 
   compare_and_jump_immediate(_,EA_jmp,"E",Reg,_),
   direct_jump(EA_jmp,EA_dst).

cmp_defines(EA_jmp,EA_dst,Reg) :- 
   compare_and_jump_immediate(_,EA_jmp,"NE",Reg,_),
   may_fallthrough(EA_jmp,EA_dst).

compare_and_jump_immediate(EA_cmp,EA_jmp,CC,Reg,Immediate) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   instruction(EA_cmp,_,_,Operation,_,_,_,_,_,_),
   arch_cmp_operation(Operation),
   cmp_immediate_to_reg(EA_cmp,Reg,_,Immediate).

compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   instruction(EA_cmp,_,_,CmpOperation,_,_,_,_,_,_),
   arch_cmp_operation(CmpOperation),
   instruction_get_op(EA_cmp,_,IndirectOp),
   op_indirect(IndirectOp,_,_,_,_,_,_),
   instruction_get_op(EA_cmp,_,ImmOp),
   op_immediate(ImmOp,Immediate,_).

compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,CC),
   cmp_reg_to_reg(EA_cmp,Reg1,Reg2).

.decl value_reg_debug(EA:address,Reg:register,
                EA_reg1:address,Offset:number)
.printsize value_reg_debug
.output value_reg_debug

value_reg_debug(EARegDef,Reg,EADef, Value) :- 
   value_reg(EARegDef,Reg,EADef,"NONE",0,Value, _).

const_value_reg_used(UsedEA,EADef,EARegDef,Reg,Value) :- 
   value_reg(EARegDef,Reg,EADef,"NONE",0,Value,_),
   reg_def_use_def_used(EARegDef,Reg,UsedEA,_).

def_used_for_address(EA_def,Reg,Type) :- 
   reg_def_use_def_used(EA_def,Reg,EA,_),
   reg_used_for(EA,Reg,Type).

def_used_for_address(EA_def,Reg,Type) :- 
   def_used_for_address(EA_used,_,Type),
   reg_def_use_def_used(EA_def,Reg,EA_used,_).

stack_def_use_def_used_(EAStore,RegBaseStore,StackPosStore,EALoad,RegBaseLoad,StackPosLoad,x):-
   stack_def_use_def_used(EAStore,[RegBaseStore,StackPosStore],EALoad,[RegBaseLoad,StackPosLoad],x).

def_used_for_address(EA_def,Reg1,Type) :- 
   def_used_for_address(EALoad,Reg2,Type),
   arch_memory_access("LOAD",EALoad,_,_,Reg2,RegBaseLoad,inlined_IndexReg_113,_,StackPosLoad),
   inlined_IndexReg_113 = "NONE",
   stack_def_use_def_used(EAStore,[RegBaseStore,StackPosStore],EALoad,[RegBaseLoad,StackPosLoad],_),
   arch_memory_access("STORE",EAStore,_,_,Reg1,RegBaseStore,inlined_IndexReg_548,_,StackPosStore),
   inlined_IndexReg_548 = "NONE",
   reg_def_use_def_used(EA_def,Reg1,EAStore,_).


flags_and_jump_pair(EA_flags,EA_jmp,CC) :- 
   arch_condition_flags_reg(Reg),
   reg_def_use_def_used(EA_flags,Reg,EA_jmp,_),
   arch_jump(EA_jmp),
   arch_conditional(EA_jmp,CC).

// jump_table_element_access(EA,Size,TableStartAddr,"NONE") :- 
//    pc_relative_operand(EA,1,TableStartAddr),
//    data_access(EA,_,_,_,_,_,_,Size),
//    def_used_for_address(EA,_,Type),
//    Type = "Jump",
//    reg_def_use_def_used(EA,Reg1,EA_add,_),
//    reg_def_use_def_used(EA2,Reg2,EA_add,_),
//    take_address(EA2,TableStartAddr),
//    arch_reg_reg_arithmetic_operation(EA_add,_,Reg2,Reg1,1,0),
//    data_segment(Beg,End),
//    TableStartAddr >= Beg,
//    TableStartAddr <= End.

// jump_table_element_access(EA,Size,TableStartAddr,"NONE") :- 
//    pc_relative_operand(EA,1,TableStartAddr),
//    data_access(EA,_,_,_,_,_,_,Size),
//    def_used_for_address(EA,_,Type),
//    Type = "Call",
//    reg_def_use_def_used(EA,Reg1,EA_add,_),
//    reg_def_use_def_used(EA2,Reg2,EA_add,_),
//    take_address(EA2,TableStartAddr),
//    arch_reg_reg_arithmetic_operation(EA_add,_,Reg2,Reg1,1,0),
//    data_segment(Beg,End),
//    TableStartAddr >= Beg,
//    TableStartAddr <= End.

jump_table_element_access(EA,Size,as(TableStart, address),as(RegBase, register)) :- 
   data_access(EA,_,"NONE",RegBase,RegIndex,1,0,Size),
   RegBase != "NONE",
   RegIndex != "NONE",
   RegIndex_nn = as(RegIndex, register),
   const_value_reg_used(EA,_,_,RegIndex_nn,TableStart),
   data_segment(Beg,End),
   as(TableStart, address) >= Beg,
   as(TableStart, address) <= End.

jump_table_element_access(EA,Size,as(Tmp1, address),as(RegIndex, register)) :-
   data_access(EA,_,"NONE",RegBase,RegIndex, _tmp_70,Offset,Size),
   RegBase != "NONE",
   RegBase_nn = as(RegBase, register),
   RegIndex != "NONE",
   const_value_reg_used(EA,_,_,RegBase_nn,Base),
   Tmp1 = (Base+Offset),
   data_segment(Beg,End),
   as(Tmp1, address) >= Beg,
   as(Tmp1, address) <= End,
   _tmp_70 = as(Size, number).

jump_table_signed(TableStart,Signed) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   arch_extend_load(EA,Signed, _tmp_71),
    _tmp_71 = (8*Size).

jump_table_signed(TableStart,Signed) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_used,_,EA,Reg,_,_,_),
   arch_extend_reg(EA_used,Reg,Signed, _tmp_72),
    _tmp_72 = (8*Size).

jump_table_signed(TableStart,0) :- 
   jump_table_element_access(EA,_,TableStart,_),
   instruction_get_dest_op(EA,_,DstOp),
   op_regdirect(DstOp,DefReg),
   reg_map(DefReg,DefRegMapped),
   value_reg(EA_used,_,EA,DefRegMapped,_,_,_),
   instruction_get_src_op(EA_used,_,Op),
   op_regdirect(Op,UsedReg),
   reg_map(UsedReg,DefRegMapped),
   arch_register_size_bytes(DefReg,DefSize),
   arch_register_size_bytes(UsedReg,UsedSize),
   UsedSize > DefSize.

jump_table_signed(TableStart,1) :- 
   jump_table_element_access(_,PtrSize,TableStart,_),
   PtrSize = 8.

jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
   Reg != "NONE",
   reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
   reg_call(EA_jump,_),
   code_in_block(EA_jump,_).

// .decl jump_table_start_tmp1(EA_reg1:address, Multiplier:number, Offset:number)
// .printsize jump_table_start_tmp1
// jump_table_start_tmp1(EA, Scale,Base) :-
//    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
//    reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
//    Reg != "NONE".

// .decl jump_table_start_tmp1(
//    EA:address,Reg:register, Reg1:reg_nullable, Multiplier:number,
//    Offset:number, Size:unsigned,TableStart:address)
// .printsize jump_table_start_tmp1
// jump_table_start_tmp1(EA_add,RegJump,Reg,Scale,Base,Size,TableStart) :-
//    jump_table_element_access(EA,Size,TableStart,_),
//    value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
//    Reg != "NONE".

// .decl jump_table_start_tmp2(EA_def:address,Var:register,EA_used:address)
// .printsize jump_table_start_tmp2
// jump_table_start_tmp2(EA_add,RegJump,EA_jump) :-
//    reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
//    reg_call(EA_jump,_),
//    code_in_block(EA_jump,_).

jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
   Reg != "NONE",
   reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
   reg_call(EA_jump,_),
   code_in_block(EA_jump,_).

jump_table_start(EA_jump,Size,TableStart,as(Base, address),Scale) :- 
   jump_table_element_access(EA,Size,TableStart,_),
   value_reg(EA_add,RegJump,EA,Reg,Scale,Base,_),
   Reg != "NONE",
   reg_def_use_def_used(EA_add,RegJump,EA_jump,_),
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_).

jump_table_start(EA_jump,Size,as(TableReference, address),as(TableReference, address),1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_591,_,_,_,_,_,_),
   inlined_Operation_591 = "ADD",
   jump_table_element_access(EA_base,Size, _tmp_73,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
    _tmp_73 = as(TableReference, address).

jump_table_start(EA_jump,Size,as(TableReference, address),as(TableReference, address),-1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_593,_,_,_,_,_,_),
   inlined_Operation_593 = "SUB",
   jump_table_element_access(EA_base,Size, _tmp_74,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
    _tmp_74 = as(TableReference, address).

jump_table_start(EA_jump,Size,TableStart,as(TableReference, address),1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_590,_,_,_,_,_,_),
   inlined_Operation_590 = "ADD",
   jump_table_element_access(EA_base,Size,TableStart,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
   code_in_block( _tmp_153,_),
    _tmp_153 = as(TableReference, address).

jump_table_start(EA_jump,Size,TableStart,as(TableReference, address),-1) :- 
   reg_jump(EA_jump,_),
   code_in_block(EA_jump,_),
   reg_def_use_def_used(EA_base,Reg,EA_jump,_),
   instruction(EA_base,_,_,inlined_Operation_592,_,_,_,_,_,_),
   inlined_Operation_592 = "SUB",
   jump_table_element_access(EA_base,Size,TableStart,_),
   const_value_reg_used(EA_base,_,_,Reg,TableReference),
   code_in_block( _tmp_154,_),
    _tmp_154 = as(TableReference, address).

jump_table_target(EA,Dest) :- 
   jump_table_start(EA,Size,TableStart,_,_),
   relative_jump_table_entry_candidate(_,TableStart,Size,_,Dest,_,_).

last_value_reg_limit(From,To,Reg,Value,LimitType,0) :- 
   value_reg_limit(From,To,Reg,Value,LimitType).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   !conditional_jump(BlockEnd),
   Tmp1 = (Steps+1).

// .decl last_value_reg_limit_tmp0(Block:address,PropagatedReg:register,PropagatedVal:number,PropagatedType:limit_type)
// .printsize last_value_reg_limit_tmp0
// .output last_value_reg_limit_tmp0
// last_value_reg_limit_tmp0(Block, PropagatedReg,PropagatedVal,PropagatedType) :- 
//    last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
//    Steps <= 3,
//    code_in_block(EA,Block).
// .output code_in_block

// .decl last_value_reg_limit1(BlockEnd:address,BlockNext:address,PropagatedReg:register,PropagatedVal:number,PropagatedType:limit_type,Step: unsigned)
// .printsize last_value_reg_limit1
// .output last_value_reg_limit1
// last_value_reg_limit1(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
//    last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
//    Steps <= 3,
//    code_in_block(EA,Block),
//    block_next(Block,BlockEnd,BlockNext),
//    !reg_def_use_defined_in_block(Block,PropagatedReg),
//    !conditional_jump(BlockEnd),
//    Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   no_value_reg_limit(BlockEnd),
   Tmp1 = (Steps + 1).


last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType, Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   cmp_defines(BlockEnd,BlockNext,Reg),
   Reg != PropagatedReg,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   cmp_defines(BlockEnd,DefinedNext,PropagatedReg),
   BlockNext != DefinedNext,
   Tmp1 = (Steps + 1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,Reg,_,_),
   Reg != PropagatedReg,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,PropagatedReg,Val,Type),
   PropagatedType = "MAX",
   Type = "MAX",
   PropagatedVal < Val,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,BlockNext,PropagatedReg,PropagatedVal,PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,PropagatedReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_next(Block,BlockEnd,BlockNext),
   !reg_def_use_defined_in_block(Block,PropagatedReg),
   value_reg_limit(BlockEnd,BlockNext,PropagatedReg,Val,Type),
   PropagatedType = "MIN",
   Type = "MIN",
   PropagatedVal > Val,
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(BlockEnd,DstReg,SrcReg,Offset),
   EA <= BlockEnd,
   BlockEnd <= BlockEnd,
   code_in_block(BlockEnd,Block),
   block_next(Block,BlockEnd,EA_next),
   !reg_def_use_block_last_def(BlockEnd,_,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(BlockEnd,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   last_value_reg_limit(From,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(BlockEnd,DstReg,SrcReg,Offset),
   EA <= BlockEnd,
   BlockEnd <= BlockEnd,
   code_in_block(BlockEnd,Block),
   block_next(Block,BlockEnd,EA_next),
   reg_def_use_block_last_def(BlockEnd,From,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(EA_mov,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType, Tmp1) :- 
   last_value_reg_limit(From,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
   EA <= EA_mov,
   EA_mov <= BlockEnd,
   code_in_block(EA_mov,Block),
   EA_mov != BlockEnd,
   code_in_block(EA_mov,inlined_Block_193),
   may_fallthrough(EA_mov,EA_next),
   code_in_block(EA_next,inlined_Block_193),
   reg_def_use_block_last_def(EA_mov,From,SrcReg),
   Tmp1 = (Steps+1).

last_value_reg_limit(EA_mov,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
   last_value_reg_limit(_,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
   Steps <= 3,
   code_in_block(EA,Block),
   block_last_instruction(Block,BlockEnd),
   limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
   EA <= EA_mov,
   EA_mov <= BlockEnd,
   code_in_block(EA_mov,Block),
   EA_mov != BlockEnd,
   code_in_block(EA_mov,inlined_Block_194),
   may_fallthrough(EA_mov,EA_next),
   code_in_block(EA_next,inlined_Block_194),
   !reg_def_use_block_last_def(EA_mov,_,SrcReg),
   Tmp1 = (Steps+1).

// .decl last_value_reg_limit_tmp6(From:address,To:address,Reg:register,Value:number,LimitType:limit_type,Steps:unsigned)
// .printsize last_value_reg_limit_tmp6
// .output last_value_reg_limit_tmp6
// last_value_reg_limit_debug(EA_mov,EA_next,DstReg,(PropagatedVal+Offset),PropagatedType,Tmp1) :- 
//    last_value_reg_limit(_,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
//    Steps <= 3,
//    code_in_block(EA,Block),
//    block_last_instruction(Block,BlockEnd),
//    limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
//    EA <= EA_mov,
//    EA_mov <= BlockEnd,
//    code_in_block(EA_mov,Block),
//    EA_mov != BlockEnd,
//    code_in_block(EA_mov,inlined_Block_194),
//    may_fallthrough(EA_mov,EA_next),
//    code_in_block(EA_next,inlined_Block_194),
//    !reg_def_use_block_last_def(EA_mov,_,SrcReg),
//    Tmp1 = (Steps+1).


// .decl last_value_reg_limit_debug(EA_mov:address, From:address, SrcReg:register)
// .printsize last_value_reg_limit_debug
// .output last_value_reg_limit_debug
// last_value_reg_limit_debug(EA_mov, From,  SrcReg) :-
//    last_value_reg_limit(From,EA,SrcReg,PropagatedVal,PropagatedType,Steps),
//    Steps <= 3,
//    code_in_block(EA,Block),
//    block_last_instruction(Block,BlockEnd),
//    limit_reg_op(EA_mov,DstReg,SrcReg,Offset),
//    EA <= EA_mov,
//    EA_mov <= BlockEnd,
//    code_in_block(EA_mov,Block),
//    EA_mov != BlockEnd,
//    code_in_block(EA_mov,inlined_Block_193),
//    may_fallthrough(EA_mov,EA_next),
//    code_in_block(EA_next,inlined_Block_193),
//    reg_def_use_block_last_def(EA_mov,From,SrcReg)
//    // Tmp1 = (Steps+1)
   // .

.decl no_value_reg_limit_debug(EA_jmp:address)
.printsize no_value_reg_limit_debug
.output no_value_reg_limit_debug
.printsize no_value_reg_limit

no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "O".
no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "NO".
no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "P".
no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "PE".
no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "S".
no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,_,_),
   CC = "NS".

no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg1),
   !arch_move_reg_imm(EA,Reg1,_,_),
   !reg_def_use_block_last_def(EA_cmp,_,Reg2).

no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg2),
   !arch_move_reg_imm(EA,Reg2,_,_),
   !reg_def_use_block_last_def(EA_cmp,_,Reg1).

no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,_,Reg1,Reg2),
   reg_def_use_block_last_def(EA_cmp,EA,Reg1),
   !arch_move_reg_imm(EA,Reg1,_,_),
   reg_def_use_block_last_def(EA_cmp,_,Reg2),
   !arch_move_reg_imm(EA,Reg2,_,_).

.decl instruction_non_cmp(EA:address)
.printsize instruction_non_cmp
.output instruction_non_cmp

instruction_non_cmp(EA) :- 
   instruction(EA,_,_,Operation,_,_,_,_,_,_),
   !arch_cmp_operation(Operation).

no_value_reg_limit_debug(EA_jmp),
no_value_reg_limit(EA_jmp) :- 
   flags_and_jump_pair(EA_cmp,EA_jmp,_),
   instruction(EA_cmp,_,_,Operation,_,_,_,_,_,_),
   !arch_cmp_operation(Operation).


reg_def_use_def_used_debug(EA_def,Var,EA_used,Index),
reg_def_use_def_used(EA_def,Var,EA_used,Index) :-
   reg_def_use_used(EA_used,Var,Index),
   reg_def_use_block_last_def(EA_used,EA_def,Var).

reg_def_use_def_used_debug(EA_def,VarIdentity,EA_used,Index),
reg_def_use_def_used(EA_def,VarIdentity,EA_used,Index) :- 
   reg_def_use_live_var_at_block_end(Block,BlockUsed,Var),
   reg_def_use_live_var_def(Block,VarIdentity,Var,EA_def),
   reg_def_use_live_var_used(BlockUsed,Var,Var,EA_used,Index,_). 
// .plan 1:(3,1,2)

reg_def_use_def_used_debug(EA_def,Var,Next_EA_used,NextIndex),
reg_def_use_def_used(EA_def,Var,Next_EA_used,NextIndex) :- 
   reg_def_use_live_var_at_prior_used(EA_used,NextUsedBlock,Var),
   reg_def_use_def_used(EA_def,Var,EA_used,_),
   reg_def_use_live_var_used(NextUsedBlock,Var,Var,Next_EA_used,NextIndex,_).

.printsize reg_def_use_live_var_used_tmp1
reg_def_use_live_var_used_tmp1(Block,LiveVar,EA_used,Index) :- 
   reg_def_use_live_var_used(Block,LiveVar,LiveVar,EA_used,Index,_).

.decl reg_def_use_def_used_tmp2(EA_used:address,Var:register,Next_EA_used:address,NextIndex:operand_index)
.printsize reg_def_use_def_used_tmp2
.output reg_def_use_def_used_tmp2
reg_def_use_def_used_tmp2(EA_used, Var, Next_EA_used, NextIndex) :-
   reg_def_use_live_var_at_prior_used(EA_used,NextUsedBlock,Var),
   reg_def_use_live_var_used(NextUsedBlock,Var,Var,Next_EA_used,NextIndex,_).

reg_def_use_def_used_debug(EA_def,Reg,EA_used,Index),
reg_def_use_def_used(EA_def,Reg,EA_used,Index) :- 
   reg_def_use_return_val_used(_,Callee,Reg,EA_used,Index),
   reg_def_use_return_block_end(Callee,_,_,BlockEnd),
   reg_def_use_block_last_def(BlockEnd,EA_def,Reg).

reg_def_use_return_val_used(EA_call,Callee,Reg,EA_used,Index_used) :- 
   arch_return_reg(Reg),
   reg_def_use_def_used(EA_call,Reg,EA_used,Index_used),
   direct_call(EA_call,Callee).

// reg_has_base_image(EA,Reg) :- 
//    reg_has_base_image(EA2,Reg2),
//    reg_def_use_def_used(EA2,Reg2,EA,_),
//    arch_move_reg_reg(EA,Reg,Reg2).

// reg_has_base_image(EA,Reg) :- 
//    reg_has_base_image(EA2,Reg2),
//    reg_def_use_def_used(EA2,Reg2,EA,_),
//    arch_reg_reg_arithmetic_operation(EA,Reg,Reg2,_,Mult,0),
//    Mult > 1.

// reg_reg_arithmetic_operation_defs(EA,Reg_def,EA_def1,Reg1,EA_def2,Reg2,Mult,Offset) :- 
//    def_used_for_address(EA,Reg_def,_),
//    arch_reg_reg_arithmetic_operation(EA,Reg_def,Reg1,Reg2,Mult,Offset),
//    Reg1 != Reg2,
//    reg_def_use_def_used(EA_def1,Reg1,EA,_),
//    EA != EA_def1,
//    reg_def_use_def_used(EA_def2,Reg2,EA,_),
//    EA != EA_def2.
// .plan 1:(3,1,2,4), 2:(4,1,2,3)

.printsize value_reg_limit
value_reg_limit(EA_jmp,EA_branch,Reg,Tmp1,BranchLT) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,Reg,Immediate),
   track_register(Reg),
   limit_type_map(CC,BranchLT,_,BranchOffset,_),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+BranchOffset).

value_reg_limit(EA_jmp,EA_fallthrough,Reg,Tmp1,FallthroughLT) :- 
   compare_and_jump_immediate(_,EA_jmp,CC,Reg,Immediate),
   track_register(Reg),
   limit_type_map(CC,_,FallthroughLT,_,FallthroughOffset),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+FallthroughOffset).

value_reg_limit(EA_jmp,EA_branch,Reg2,Tmp1,LT1) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,LT1,_,Offset1,_),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg1),
   arch_move_reg_imm(EA_regdef,Reg1,Immediate,_),
   track_register(Reg2),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+Offset1).

value_reg_limit(EA_jmp,EA_branch,Reg1,Tmp1,LT2) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,_,LT2,_,Offset2),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg2),
   arch_move_reg_imm(EA_regdef,Reg2,Immediate,_),
   track_register(Reg1),
   direct_jump(EA_jmp,EA_branch),
   may_fallthrough(EA_jmp,_),
   Tmp1 = (Immediate+Offset2).

value_reg_limit(EA_jmp,EA_fallthrough,Reg2,Tmp1,LT2) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,_,LT2,_,Offset2),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg1),
   arch_move_reg_imm(EA_regdef,Reg1,Immediate,_),
   track_register(Reg2),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+Offset2).

value_reg_limit(EA_jmp,EA_fallthrough,Reg1,Tmp1,LT1) :- 
   compare_and_jump_register(EA_cmp,EA_jmp,CC,Reg1,Reg2),
   limit_type_map(CC,LT1,_,Offset1,_),
   reg_def_use_block_last_def(EA_cmp,EA_regdef,Reg2),
   arch_move_reg_imm(EA_regdef,Reg2,Immediate,_),
   track_register(Reg1),
   direct_jump(EA_jmp,_),
   may_fallthrough(EA_jmp,EA_fallthrough),
   Tmp1 = (Immediate+Offset1).

value_reg_limit(EA_target,EA_limited,Reg,Tmp1,BranchLT) :- 
   compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate),
   limit_type_map(CC,BranchLT,_,BranchOffset,_),
   next(EA_cmp,EA_jmp),
   direct_jump(EA_jmp,EA_target),
   arch_memory_access("LOAD",EA_target,_,_,Reg,_,_,_,_),
   track_register(Reg),
   instruction_get_op(EA_target,_,IndirectOp),
   code_in_block(EA_target,inlined_Block_887),
   may_fallthrough(EA_target,EA_limited),
   code_in_block(EA_limited,inlined_Block_887),
   Tmp1 = (Immediate+BranchOffset).

value_reg_limit(EA_target,EA_limited,Reg,Tmp1,FallthroughLT) :- 
   compare_and_jump_indirect(EA_cmp,EA_jmp,CC,IndirectOp,Immediate),
   limit_type_map(CC,_,FallthroughLT,_,FallthroughOffset),
   next(EA_cmp,EA_jmp),
   may_fallthrough(EA_jmp,EA_target),
   arch_memory_access("LOAD",EA_target,_,_,Reg,_,_,_,_),
   track_register(Reg),
   instruction_get_op(EA_target,_,IndirectOp),
   code_in_block(EA_target,inlined_Block_888),
   may_fallthrough(EA_target,EA_limited),
   code_in_block(EA_limited,inlined_Block_888),
   Tmp1 = (Immediate+FallthroughOffset).


value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_move_reg_reg(EA,Dst,Src),
   track_register(Dst),
   !track_register(Src).
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_call(EA,_).
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,_,_,Reg,RegBase,_,_,_),
   RegBase != "NONE".
value_reg_unsupported(EA,Reg) :- 
   def_used_for_address(EA,Reg,_),
   arch_memory_access("LOAD",EA,_,_,Reg,_,RegIndex,_,_),
   RegIndex != "NONE".
